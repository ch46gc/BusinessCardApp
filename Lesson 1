What happens when you initialize a repository? Why do you need to do it?
	
	Initializing the repository creates the hidden .git folder where the Git information is stored.  
  This setups the version control of the reflections folder creating our repository in order to start controlling the versions.

How is the staging area different from the working directory and the repository? What value do you think it offers?

	The staging area is where a file is added when it is ready to be committed to the respository, but the user would like to keep
  working on other files and perform the commit only one time with all the files to be committed.  This allows a user to keep
  track of which files are ready while reducing the number of commits necessary to update the respository.  This is very useful if one commit affects multiple files.

How can you use the staging area to make sure you have one commit per logical change?

	I can run the git diff command to compare the staging area and he working files to ensure I understand what changes I have staged. 
  Likewise, I can run the git diff --staged command to check what I have staged versus what I have already committed to ensure I'm doing what I thought I was doing.

What are some situations when branches would be helpful in keeping your history organized? How would branches help?

	Branches are useful when you'd like to make significant or experimental changes to your files, but you want to keep the original 
  files just the same.  This basically creates two concurrent versions of your files for different purposes.  I can then work on one 
  or the other branch easily, while still maintaining them separately.

How do the diagrams help you visualize the branch structure?

	By drawing out the structure in diagram form, it helps me understand how branches work and how the flow moves back towards the
  initial commit.  I can see that if I checkout a commit comewhere in the middle of a branch, I'm not necessarily moving the branch
  and any changes I make won't necessarily make it back to the master branch.

What is the result of merging two branches together? Why do we represent it in the diagram the way we do?

	Merging two branchs takes the changes from both branches and combines them into one final branch.  It saves all the commit 
  data between both branchs such that we can still go back in history on either branch, but at this new point we are moving forward
  in a single, megered branch.

What are the pros and cons of Gitâ€™s automatic merging vs. always doing merges manually?

	Utilizing the automatic merge, it can save the user time and effort of having to compare two branches manually.  If there is no
  obvious conflict, then the user can quickly and easily merge branches and move on.
